'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var pickOneByWeight = require('pick-one-by-weight');

var isType = function isType(t) {
  return Object.prototype.toString.call(t).slice(8, -1).toLowerCase();
};

var MarkovChain = (function () {
  function MarkovChain(contents) {
    var normFn = arguments.length <= 1 || arguments[1] === undefined ? function (word) {
      return word.replace(/\.$/ig, '');
    } : arguments[1];

    _classCallCheck(this, MarkovChain);

    this.wordBank = Object.create(null);
    this.sentence = '';
    this._normalizeFn = normFn;
    //no numbers or other symbols or punctuations - completely remove, except apostrophes - if contains these, just skip the word completely, hyphens not surrounded by two letters
    //commas stay normally as keys - remove if adding as a value; quotes just remove quotes and otherwise add word normally - deal with dashes/hypens here (see above)
    //parantheses??
    //also deal with capitalization
    this.parseBy = /(?:\.|\?|\!|\;|\:|\ - |\--|\- |\ -|\(|\)|\"|\“|\”|\[|\]|\{|\}|\n)/ig;
    this.parse(contents);
  }

  _createClass(MarkovChain, [{
    key: 'startFn',
    value: function startFn(wordList) {
      var k = Object.keys(wordList);
      var l = k.length;
      return k[~ ~(Math.random() * l)];
    }
  }, {
    key: 'endFn',
    value: function endFn() {
      return this.sentence.split(' ').length > 7;
    }
  }, {
    key: 'updateWordBank',
    value: function updateWordBank(wordBank, current, next) {
      if (current !== undefined && next !== undefined) {
        //fix this and the other regex so it isn't as messy
        //parse punctuation and standarize capitalize for input strings
        //if suggestion contains a comma or punctuation, remove it
        //remove commas from suggestions (predictnextthree function)
        //replace all weird quotes with normal
        // if (wordBank === this.wordBank) {
        //   console.log(current);
        // }
        if (!current.match(/[^(a-z , ' ’ a-zA-Z.\-_ \r)]/i) && !next.match(/[^(a-z , ' ’ a-zA-Z.\-_ \r)]/i)) {
          if (!wordBank[current]) { 
            wordBank[current] = Object.create(null);
          }
          if (!wordBank[current][next]) {
            wordBank[current][next] = 1;
          } 
          else {
            wordBank[current][next] += 1;
          }
        }
        // else {
        //   console.log(current);
        //   console.log(current.match(/[^(a-z , ' ’ a-zA-Z0-9.\-_ \r)]/i))
        //   console.log(next);
        //   console.log(next.match(/[^(a-z , ' ’ a-zA-Z0-9.\-_ \r)]/i));
        // }
      }
      return wordBank;
    }
  }, {
    key: 'process',
    value: function process(predictTopThree = null) {
      var curWord = this.startFn(this.wordBank);
      var wordBanks = [this.wordBank3, this.wordBank2, this.wordBank];
      var split = curWord.split(" ");
      var sentence = "";
      var strings = [];
      var i = 2;
      while (i < (split.length + 1) && i < 5) {
        if (i == 2) {
          sentence = split[split.length - 2];
        }
        else {
          sentence = split[split.length - i] + " " + sentence; 
        }
        strings.push(sentence);
        i++;
      }
      if (predictTopThree == null) {
        var suggestions = [];
        while (this.wordBank[strings[0]] && suggestions.length < 10) {
          var prediction = pickOneByWeight(this.wordBank[strings[0]]);
          suggestions.push(prediction);
        }
        return suggestions;
      }
      else {
        return predictTopThree(curWord, this.wordBank);
      }
    }
  }, {
    key: 'parse',
    value: function parse() {
      var _this = this;

      var text = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
      var parseBy = arguments.length <= 1 || arguments[1] === undefined ? this.parseBy : arguments[1];

      text.split(parseBy).forEach(function (lines) {
        var words = lines.split(' ').filter(function (w) {
          return w.trim() !== '';
        });
        for (var i = 0; i < words.length - 1; i++) {
             //do this for single words (curword, next, etc. before combining)
           //options: Time vs. time (if first char uppercase - check if lowercase/uppercase exists - if yes, make lowercase, otherwise add to uppercase); 
            //; hElLo (to lowercase - check if it makes everything lowercase), HELLO (to lowercase)
           var curWords = [];
           curWords.push(_this._normalize(words[i]));
           curWords.push(_this._normalize(words[i + 1]));
           curWords.push(_this._normalize(words[i + 2]));
           curWords.push(_this._normalize(words[i + 3]));

           for (var j = 0; j < 4; j++) {
              if (curWords[j] !== undefined) {
                curWords[j] = curWords[j].replace(/’/g, "'");
                // if (curWords[j])
              }
           }

           var twoWords = curWords[0] + " " + curWords[1];
           var threeWords = curWords[0] + " " + curWords[1] + " " + curWords[2];

           _this.wordBank = _this.updateWordBank(_this.wordBank, curWords[0], curWords[1]);
           _this.wordBank2 = _this.updateWordBank(_this.wordBank2, twoWords, curWords[2]);
           _this.wordBank3 = _this.updateWordBank(_this.wordBank3, threeWords, curWords[3]);
           
          //  if (!_this.wordBank[curWord]) {
          //    _this.wordBank[curWord] = Object.create(null);
          //  }
          //  if (!_this.wordBank2[twoWords]) {
          //    _this.wordBank2[twoWords] = Object.create(null);
          //  }
          //  if (!_this.wordBank3[threeWords]) {
          //    _this.wordBank3[threeWords] = Object.create(null);
          //  }
          //  if (!_this.wordBank[curWord][nextWord]) {
          //    _this.wordBank[curWord][nextWord] = 1;
          //  } else {
          //    _this.wordBank[curWord][nextWord] += 1;
          //  }
          //  if (!_this.wordBank2[twoWords][thirdWord]) {
          //    _this.wordBank2[twoWords][thirdWord] = 1;
          //  } else {
          //    _this.wordBank2[twoWords][thirdWord] += 1;
          //  }
          //  if (!_this.wordBank3[threeWords][fourthWord]) {
          //    _this.wordBank3[threeWords][fourthWord] = 1;
          //  } else {
          //    _this.wordBank3[threeWords][fourthWord] += 1;
          //  }
        }
      });
      return this;
    }
  }, {
    key: 'start',
    value: function start(fnStr) {
      var startType = isType(fnStr);
      if (startType === 'string') {
        this.startFn = function () {
          return fnStr;
        };
      } else if (startType === 'function') {
        this.startFn = function (wordList) {
          return fnStr(wordList);
        };
      } else {
        throw new Error('Must pass a function, or string into start()');
      }
      return this;
    }
  }, {
    key: 'end',
    value: function end(fnStrOrNum) {
      var _this2 = this;

      var endType = isType(fnStrOrNum);
      var self = this;

      if (endType === 'function') {
        this.endFn = function () {
          return fnStrOrNum(_this2.sentence);
        };
      } else if (endType === 'string') {
        this.endFn = function () {
          return _this2.sentence.split(' ').slice(-1)[0] === fnStrOrNum;
        };
      } else if (endType === 'number' || fnStrOrNum === undefined) {
        fnStrOrNum = fnStrOrNum || Infinity;
        this.endFn = function () {
          return self.sentence.split(' ').length > fnStrOrNum;
        };
      } else {
        throw new Error('Must pass a function, string or number into end()');
      }
      return this;
    }
  }, {
    key: '_normalize',
    value: function _normalize(word) {
      return this._normalizeFn(word);
    }
  }, {
    key: 'normalize',
    value: function normalize(fn) {
      this._normalizeFn = fn;
      return this;
    }
  }], [{
    key: 'VERSION',
    get: function get() {
      return require('../package').version;
    }
  }, {
    key: 'MarkovChain',
    get: function get() {
      // load older MarkovChain
      return require('../older/index.js').MarkovChain;
    }
  }]);

  return MarkovChain;
})();

module.exports = MarkovChain;