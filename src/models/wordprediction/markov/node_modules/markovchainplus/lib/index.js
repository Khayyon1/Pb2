'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

const alwaysCap = ["I", "I'll", "I'm", "I'd", "I've", 
"Christmas", "Thanksgiving", "Halloween", "Easter", "Hanukkah", "God",  
"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", 
"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

const swears = ["fuck", "shit", "arse", "bitch", "bastard", "crap", "cunt", "damn", "prick", "shag", "wank", "nut", "piss", "twat", "jack", 
                "dumbass", "asshole", "badass", "halfass", "hardass", "smartass", "balls", "cum", "dammit", "jizz", "testicles", "cunnilingus", 
                "fellatio", "scrotum", "boner", "blowjob", "sex", "slut", "dick", "cock", "tit", "boob", "vagina", "penis", "pussy", "bollocks", 
                "porn", "orgasm", "nigg", "whore", "fag", "coon", "hellbent", "hellfire", "hell fire"];
const swearsReg = new RegExp(swears.join( "|" ), "i"); 

var isType = function isType(t) {
  return Object.prototype.toString.call(t).slice(8, -1).toLowerCase();
};

var MarkovChain = (function () {
  function MarkovChain(contents) {
    var normFn = arguments.length <= 1 || arguments[1] === undefined ? function (word) {
      if (word !== undefined) {
        return word.replace(/\.$/ig, '');
      }
      else {
        return word;
      }
    } : arguments[1];

    _classCallCheck(this, MarkovChain);
    this.wordBank = Object.create(null);
    this.wordBank2 = Object.create(null);
    this.wordBank3 = Object.create(null);
    this.sentence = '';
    this._normalizeFn = normFn;
    this.parseBy = /(?:\.|\?|\!|\;|\:|\ - |\--|\- |\ -|\(|\)|\"|\“|\”|\[|\]|\{|\}|\n)/ig;
    this.parse(contents);
  }

  _createClass(MarkovChain, [{
    key: 'startFn',
    value: function startFn(wordList) {
      var k = Object.keys(wordList);
      var l = k.length;
      return k[~ ~(Math.random() * l)];
    }
  }, {
    key: 'endFn',
    value: function endFn() {
      return this.sentence.split(' ').length > 7;
    }
  }, {
    key: 'parseCurPhrase',
    value: function parseCurPhrase(curPhrase) {
      curPhrase = curPhrase.replace(/ ,/g, ', ');
      if (curPhrase.length > 1) {
        curPhrase = curPhrase[0].replace(/,/, '') + curPhrase.slice(1);
        curPhrase = curPhrase.slice(0, curPhrase.length - 1) + curPhrase[curPhrase.length - 1].replace(/\s/, '');
      }
      return curPhrase;
    }
  }, {
    key: 'nextWordValid',
    value: function nextWordValid(nextWord) {
      if (!swearsReg.test(nextWord) && nextWord !== "hell" && nextWord !== "ass") {
        if (nextWord.length > 1) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'isUndefined',
    value: function isUndefined(curPhrase, nextWord) {
      if (curPhrase !== undefined && nextWord !== undefined) {
        if (!curPhrase.includes(undefined) && !nextWord.includes(undefined)) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: 'updateWordBank',
    value: function updateWordBank(wordBank, curPhrase, nextWord) {
      var reg = /[^a-z , ' ’ a-zA-Z.\-_ \r]/i;  
      if (!this.isUndefined(curPhrase, nextWord)) {
        if (!reg.test(curPhrase) && !reg.test(nextWord)) {
          nextWord = nextWord.replace(/,/g, '');
          if (this.nextWordValid(nextWord)) {
            curPhrase = this.parseCurPhrase(curPhrase);
            if (!wordBank[curPhrase]) {    
              wordBank[curPhrase] = Object.create(null);
            }
            if (!wordBank[curPhrase][nextWord]) {
              wordBank[curPhrase][nextWord] = 1;
            } 
            else {
              wordBank[curPhrase][nextWord] += 1;
            }
          }
        }
      }
      return wordBank;
    }
  }, {
    key: 'process',
    value: function process(predict) {
      var curString = this.startFn(this.wordBank);
      var wordBanks = [this.wordBank3, this.wordBank2, this.wordBank];
      var split = curString.split(/[\r\n({[$%^*_+@~`\"“”<>\/\s+]/i); 
      while (split.includes('')) {
        split.splice(split.indexOf(''), 1);
      }
      var sentence = "";
      var strings = [];
      var i = 1;
      while (i < (split.length + 1) && i < 4) {
        var curWord = split[split.length - i];
        var upper = curWord[0].toUpperCase() + curWord.slice(1).toLowerCase();
        if (alwaysCap.includes(upper)) {
          curWord = upper;
        }
        else {
          curWord = curWord.toLowerCase();
        }
        if (curWord === "&") {
          curWord = "and";
        }
        if (i == 1) {
          sentence = curWord;
        }
        else {
          sentence = curWord + " " + sentence; 
        }
        strings.push(sentence);
        i++;
      }
      wordBanks.splice(0, (wordBanks.length - strings.length));
      return predict(strings.reverse(), wordBanks);
    }
  }, {
    key: 'parse',
    value: function parse() {
      var _this = this;

      var text = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
      var parseBy = arguments.length <= 1 || arguments[1] === undefined ? this.parseBy : arguments[1];

      text.split(parseBy).forEach(function (lines) {
        var words = lines.split(' ').filter(function (w) {
          return w.trim() !== '';
        });
        if (words.length > 0) {
          words[0] = words[0].toLowerCase();
        }

        for (var i = 0; i < words.length - 3; i++) { 
          var curWords = [];
          //combine this into loop below ... or just do it in words[?]. 
          //move that long word list somewhere up above and make it a const
          //clean up parseby regex
          //add comments
          curWords.push(_this._normalize(words[i]));
          curWords.push(_this._normalize(words[i + 1]));
          curWords.push(_this._normalize(words[i + 2]));
          curWords.push(_this._normalize(words[i + 3]));

          for (var j = 0; j < curWords.length; j++) {
            if (curWords[j] !== undefined) {
              curWords[j] = curWords[j].replace(/’/g, "'");
              curWords[j] = curWords[j][0] + curWords[j].slice(1).toLowerCase();
              var upper = curWords[j][0].toUpperCase() + curWords[j].slice(1);
              if (alwaysCap.includes(upper)) {
                curWords[j] = upper;
              }
              else if (!alwaysCap.includes(upper) && /[A-Z]/.test(curWords[j][0])) {
                curWords[j] = undefined;
              }
            }
          }

          var twoWords = curWords[0] + " " + curWords[1];
          var threeWords = curWords[0] + " " + curWords[1] + " " + curWords[2];
          _this.wordBank = _this.updateWordBank(_this.wordBank, curWords[0], curWords[1]);
          _this.wordBank2 = _this.updateWordBank(_this.wordBank2, twoWords, curWords[2]);
          _this.wordBank3 = _this.updateWordBank(_this.wordBank3, threeWords, curWords[3]);
        }
      });
      return this;
    }
  }, {
    key: 'start',
    value: function start(fnStr) {
      var startType = isType(fnStr);
      if (startType === 'string') {
        this.startFn = function () {
          return fnStr;
        };
      } else if (startType === 'function') {
        this.startFn = function (wordList) {
          return fnStr(wordList);
        };
      } else {
        throw new Error('Must pass a function, or string into start()');
      }
      return this;
    }
  }, {
    key: 'end',
    value: function end(fnStrOrNum) {
      var _this2 = this;

      var endType = isType(fnStrOrNum);
      var self = this;

      if (endType === 'function') {
        this.endFn = function () {
          return fnStrOrNum(_this2.sentence);
        };
      } else if (endType === 'string') {
        this.endFn = function () {
          return _this2.sentence.split(' ').slice(-1)[0] === fnStrOrNum;
        };
      } else if (endType === 'number' || fnStrOrNum === undefined) {
        fnStrOrNum = fnStrOrNum || Infinity;
        this.endFn = function () {
          return self.sentence.split(' ').length > fnStrOrNum;
        };
      } else {
        throw new Error('Must pass a function, string or number into end()');
      }
      return this;
    }
  }, {
    key: '_normalize',
    value: function _normalize(word) {
      return this._normalizeFn(word);
    }
  }, {
    key: 'normalize',
    value: function normalize(fn) {
      this._normalizeFn = fn;
      return this;
    }
  }], [{
    key: 'VERSION',
    get: function get() {
      return require('../package').version;
    }
  }, {
    key: 'MarkovChain',
    get: function get() {
      // load older MarkovChain
      return require('../older/index.js').MarkovChain;
    }
  }]);

  return MarkovChain;
})();

module.exports = MarkovChain;