'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var pickOneByWeight = require('pick-one-by-weight');

const alwaysCap = ["I", "I'll", "I'm", "I'd", "I've", 
"Christmas", "Thanksgiving", "Halloween", "Easter", "Hanukkah", "God",  
"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", 
"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

var isType = function isType(t) {
  return Object.prototype.toString.call(t).slice(8, -1).toLowerCase();
};

var MarkovChain = (function () {
  function MarkovChain(contents) {
    var normFn = arguments.length <= 1 || arguments[1] === undefined ? function (word) {
      if (word !== undefined) {
        return word.replace(/\.$/ig, '');
      }
      else {
        return word;
      }
    } : arguments[1];

    _classCallCheck(this, MarkovChain);
    this.wordBank = Object.create(null);
    this.wordBank2 = Object.create(null);
    this.wordBank3 = Object.create(null);
    this.sentence = '';
    this._normalizeFn = normFn;
    this.parseBy = /(?:\.|\?|\!|\;|\:|\ - |\--|\- |\ -|\(|\)|\"|\“|\”|\[|\]|\{|\}|\n)/ig;
    this.parse(contents);
  }

  _createClass(MarkovChain, [{
    key: 'startFn',
    value: function startFn(wordList) {
      var k = Object.keys(wordList);
      var l = k.length;
      return k[~ ~(Math.random() * l)];
    }
  }, {
    key: 'endFn',
    value: function endFn() {
      return this.sentence.split(' ').length > 7;
    }
  }, {
    key: 'updateWordBank',
    value: function updateWordBank(wordBank, current, next) {
      if (current !== undefined && next !== undefined) {
        var reg = /[^(a-z , ' ’ a-zA-Z.\-_ \r)]/i;  //remove parans? also make the if statement below less messy/shorter
        if (!current.includes(undefined) && !next.includes(undefined) && !reg.test(current) && !reg.test(next)) {
          next = next.replace(/,/g, '');
          if (!wordBank[current]) {    
            wordBank[current] = Object.create(null);
          }
          if (!wordBank[current][next]) {
            wordBank[current][next] = 1;
          } 
          else {
            wordBank[current][next] += 1;
          }
        }
      }
      return wordBank;
    }
  }, {
    key: 'process',
    value: function process(predictTopThree = null) {
      var curString = this.startFn(this.wordBank);
      var wordBanks = [this.wordBank3, this.wordBank2, this.wordBank];
      var split = curString.split(/[\r\n({[$%^*_+@~`\"“”<>\/\s+]/i); 
      while (split.includes('')) {
        split.splice(split.indexOf(''), 1);
      }
      var sentence = "";
      var strings = [];
      var i = 1;
      while (i < (split.length + 1) && i < 4) {
        var curWord = split[split.length - i];
        var upper = curWord[0].toUpperCase() + curWord.slice(1).toLowerCase();
        if (alwaysCap.includes(upper)) {
          curWord = upper;
        }
        else {
          curWord = curWord.toLowerCase();
        }
        if (curWord === "&") {
          curWord = "and";
        }
        if (i == 1) {
          sentence = curWord;
        }
        else {
          sentence = curWord + " " + sentence; 
        }
        strings.push(sentence);
        i++;
      }
      if (predictTopThree == null) {
        var suggestions = [];
        while (this.wordBank[strings[0]] && suggestions.length < 10) {
          var prediction = pickOneByWeight(this.wordBank[strings[0]]);
          suggestions.push(prediction);
        }
        return suggestions;
      }
      else {
        wordBanks.splice(0, (wordBanks.length - strings.length));
        return predictTopThree(strings.reverse(), wordBanks);
      }
    }
  }, {
    key: 'parse',
    value: function parse() {
      var _this = this;

      var text = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
      var parseBy = arguments.length <= 1 || arguments[1] === undefined ? this.parseBy : arguments[1];

      text.split(parseBy).forEach(function (lines) {
        var words = lines.split(' ').filter(function (w) {
          return w.trim() !== '';
        });
        if (words.length > 0) {
          words[0] = words[0].toLowerCase();
        }

        for (var i = 0; i < words.length - 3; i++) { 
          var curWords = [];
          //combine this into loop below ... or just do it in words[?]. 
          //move that long word list somewhere up above and make it a const
          //clean up parseby regex
          //add comments
          curWords.push(_this._normalize(words[i]));
          curWords.push(_this._normalize(words[i + 1]));
          curWords.push(_this._normalize(words[i + 2]));
          curWords.push(_this._normalize(words[i + 3]));

          for (var j = 0; j < curWords.length; j++) {
            if (curWords[j] !== undefined) {
              curWords[j] = curWords[j].replace(/’/g, "'");
              curWords[j] = curWords[j][0] + curWords[j].slice(1).toLowerCase();
              var upper = curWords[j][0].toUpperCase() + curWords[j].slice(1);
              if (alwaysCap.includes(upper)) {
                curWords[j] = upper;
              }
              else if (!alwaysCap.includes(upper) && /[A-Z]/.test(curWords[j][0])) {
                curWords[j] = undefined;
              }
            }
          }

          var twoWords = curWords[0] + " " + curWords[1];
          var threeWords = curWords[0] + " " + curWords[1] + " " + curWords[2];
          _this.wordBank = _this.updateWordBank(_this.wordBank, curWords[0], curWords[1]);
          _this.wordBank2 = _this.updateWordBank(_this.wordBank2, twoWords, curWords[2]);
          _this.wordBank3 = _this.updateWordBank(_this.wordBank3, threeWords, curWords[3]);
        }
      });
      return this;
    }
  }, {
    key: 'start',
    value: function start(fnStr) {
      var startType = isType(fnStr);
      if (startType === 'string') {
        this.startFn = function () {
          return fnStr;
        };
      } else if (startType === 'function') {
        this.startFn = function (wordList) {
          return fnStr(wordList);
        };
      } else {
        throw new Error('Must pass a function, or string into start()');
      }
      return this;
    }
  }, {
    key: 'end',
    value: function end(fnStrOrNum) {
      var _this2 = this;

      var endType = isType(fnStrOrNum);
      var self = this;

      if (endType === 'function') {
        this.endFn = function () {
          return fnStrOrNum(_this2.sentence);
        };
      } else if (endType === 'string') {
        this.endFn = function () {
          return _this2.sentence.split(' ').slice(-1)[0] === fnStrOrNum;
        };
      } else if (endType === 'number' || fnStrOrNum === undefined) {
        fnStrOrNum = fnStrOrNum || Infinity;
        this.endFn = function () {
          return self.sentence.split(' ').length > fnStrOrNum;
        };
      } else {
        throw new Error('Must pass a function, string or number into end()');
      }
      return this;
    }
  }, {
    key: '_normalize',
    value: function _normalize(word) {
      return this._normalizeFn(word);
    }
  }, {
    key: 'normalize',
    value: function normalize(fn) {
      this._normalizeFn = fn;
      return this;
    }
  }], [{
    key: 'VERSION',
    get: function get() {
      return require('../package').version;
    }
  }, {
    key: 'MarkovChain',
    get: function get() {
      // load older MarkovChain
      return require('../older/index.js').MarkovChain;
    }
  }]);

  return MarkovChain;
})();

module.exports = MarkovChain;