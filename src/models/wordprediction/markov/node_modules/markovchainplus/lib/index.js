'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var pickOneByWeight = require('pick-one-by-weight');

var isType = function isType(t) {
  return Object.prototype.toString.call(t).slice(8, -1).toLowerCase();
};

var MarkovChain = (function () {
  function MarkovChain(contents) {
    var normFn = arguments.length <= 1 || arguments[1] === undefined ? function (word) {
      if (word !== undefined) {
        return word.replace(/\.$/ig, '');
      }
      else {
        return word;
      }
    } : arguments[1];

    _classCallCheck(this, MarkovChain);

    this.wordBank = Object.create(null);
    this.wordBank2 = Object.create(null);
    this.wordBank3 = Object.create(null);
    this.sentence = '';
    this._normalizeFn = normFn;
    //no numbers or other symbols or punctuations - completely remove, except apostrophes - if contains these, just skip the word completely, hyphens not surrounded by two letters
    //commas stay normally as keys - remove if adding as a value; quotes just remove quotes and otherwise add word normally - deal with dashes/hypens here (see above)
    //parantheses??
    //also deal with capitalization
    this.parseBy = /(?:\.|\?|\!|\;|\:|\ - |\--|\- |\ -|\(|\)|\"|\“|\”|\[|\]|\{|\}|\n)/ig;
    this.parse(contents);
  }

  _createClass(MarkovChain, [{
    key: 'startFn',
    value: function startFn(wordList) {
      var k = Object.keys(wordList);
      var l = k.length;
      return k[~ ~(Math.random() * l)];
    }
  }, {
    key: 'endFn',
    value: function endFn() {
      return this.sentence.split(' ').length > 7;
    }
  }, {
    key: 'updateWordBank',
    value: function updateWordBank(wordBank, current, next) {
      if (current !== undefined && next !== undefined) {
        //fix this and the other regex so it isn't as messy
        //parse punctuation and standarize capitalize for input strings
        //if suggestion contains a comma or punctuation, remove it
        //remove commas from suggestions (predictnextthree function)
        //replace all weird quotes with normal
        var reg = /[^(a-z , ' ’ a-zA-Z.\-_ \r)]/i;
        if (!reg.test(current) && !reg.test(next)) {
          if (!wordBank[current]) {    
            wordBank[current] = Object.create(null);
          }
          if (!wordBank[current][next]) {
            wordBank[current][next] = 1;
          } 
          else {
            wordBank[current][next] += 1;
          }
        }
        // else {
        //   console.log(current);
        //   console.log(current.match(/[^(a-z , ' ’ a-zA-Z0-9.\-_ \r)]/i))
        //   console.log(next);
        //   console.log(next.match(/[^(a-z , ' ’ a-zA-Z0-9.\-_ \r)]/i));
        // }
      }
      return wordBank;
    }
  }, {
    key: 'process',
    value: function process(predictTopThree = null) {
      var curWord = this.startFn(this.wordBank);
      var wordBanks = [this.wordBank3, this.wordBank2, this.wordBank];
      var split = curWord.split(" ");
      var sentence = "";
      var strings = [];
      var i = 2;
      while (i < (split.length + 1) && i < 5) {
        if (i == 2) {
          sentence = split[split.length - 2];
        }
        else {
          sentence = split[split.length - i] + " " + sentence; 
        }
        strings.push(sentence);
        i++;
      }
      if (predictTopThree == null) {
        var suggestions = [];
        while (this.wordBank[strings[0]] && suggestions.length < 10) {
          var prediction = pickOneByWeight(this.wordBank[strings[0]]);
          suggestions.push(prediction);
        }
        return suggestions;
      }
      else {
        wordBanks.splice(0, (wordBanks.length - strings.length));
        return predictTopThree(strings.reverse(), wordBanks);
      }
    }
  }, {
    key: 'parse',
    value: function parse() {
      var _this = this;

      var text = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
      var parseBy = arguments.length <= 1 || arguments[1] === undefined ? this.parseBy : arguments[1];

      text.split(parseBy).forEach(function (lines) {
        var words = lines.split(' ').filter(function (w) {
          return w.trim() !== '';
        });
        
        if (words.length > 0) {
          words[0] = words[0].toLowerCase();
        }
        var upperCaseWordLists = [];
        var alwaysCap = ["I", "I'll", "I'm", "I'd", "Christmas", "Thanksgiving", "Halloween", "Easter", "Hanukkah", 
                        "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", 
                        "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        for (var i = 0; i < words.length - 3; i++) { 
           var curWords = [];
           //combine this into loop below ... or just do it in words[?]
           curWords.push(_this._normalize(words[i]));
           curWords.push(_this._normalize(words[i + 1]));
           curWords.push(_this._normalize(words[i + 2]));
           curWords.push(_this._normalize(words[i + 3]));


           for (var j = 0; j < curWords.length; j++) {
            if (curWords[j] !== undefined) {
              curWords[j] = curWords[j].replace(/’/g, "'");
              curWords[j] = curWords[j][0] + curWords[j].slice(1).toLowerCase();
              var upper = curWords[j][0].toUpperCase + curWords[j].slice(1);
              if (alwaysCap.includes(upper)) {
                curWords[j] = upper;
              }
              else if (!alwaysCap.includes(upper) && /[A-Z]/.test(curWords[j][0])) {
                curWords[j] = undefined;
              }
            }
          }

          //  var upperIndex = [];
          //  for (var j = 0; j < 4; j++) {
          //     if (curWords[j] !== undefined) {
          //       curWords[j] = curWords[j].replace(/’/g, "'");
          //       curWords[j] = curWords[j][0] + curWords[j].slice(1).toLowerCase();
          //       if (/[A-Z]/.test(curWords[j][0])) {
          //         //console.log(curWords[j]);
          //         var lower = curWords[j].toLowerCase();
          //         //console.log(lower);
          //         if (_this.wordBank[lower]) { //if lowercase version of word already exists in wordbank
          //           //console.log("y");
          //           curWords[j] = lower;
          //         }
          //         else {
          //           //console.log("n");
          //           upperIndex.push(j);
          //         }
          //         //if lowercase version exists
          //         //else lowercase version doesn't exist: add entire curWords list to a list to deal with at the end don't know why I (check boolean and then add after loop)
          //       }
          //     }
          //  }


           if (upperIndex.length > 0) {
             upperCaseWordLists.push(curWords);
             upperCaseWordLists.push(upperIndex);
           }
           else {
             var twoWords = curWords[0] + " " + curWords[1];
             var threeWords = curWords[0] + " " + curWords[1] + " " + curWords[2];

             _this.wordBank = _this.updateWordBank(_this.wordBank, curWords[0], curWords[1]);
             _this.wordBank2 = _this.updateWordBank(_this.wordBank2, twoWords, curWords[2]);
             _this.wordBank3 = _this.updateWordBank(_this.wordBank3, threeWords, curWords[3]);
           }
        }
        // //console.log("got here");
        // for (var i = 0; i < upperCaseWordLists.length; i += 2) {
        //   var wordList = upperCaseWordLists[i];
        //   var upperIndex = upperCaseWordLists[i + 1];
        //   for (var j = 0; j < upperIndex.length; j++) {
        //     //console.log(wordList[upperIndex[j]]);
        //     var lower = wordList[upperIndex[j]].toLowerCase();
        //     //console.log(lower);
        //     if (_this.wordBank[lower]) { //search remainder of lists to see if lowercase version exists?
        //       //console.log("y");
        //       wordList[upperIndex[j]] = lower;
        //       //console.log(wordList[upperIndex[j]]);
        //     }
        //   }
        //   //new function for this
        //   var twoWords = wordList[0] + " " + wordList[1];
        //   var threeWords = wordList[0] + " " + wordList[1] + " " + wordList[2];

        //   _this.wordBank = _this.updateWordBank(_this.wordBank, wordList[0], wordList[1]);
        //   _this.wordBank2 = _this.updateWordBank(_this.wordBank2, twoWords, wordList[2]);
        //   _this.wordBank3 = _this.updateWordBank(_this.wordBank3, threeWords, wordList[3]);
        // }
      });
      return this;
    }
  }, {
    key: 'start',
    value: function start(fnStr) {
      var startType = isType(fnStr);
      if (startType === 'string') {
        this.startFn = function () {
          return fnStr;
        };
      } else if (startType === 'function') {
        this.startFn = function (wordList) {
          return fnStr(wordList);
        };
      } else {
        throw new Error('Must pass a function, or string into start()');
      }
      return this;
    }
  }, {
    key: 'end',
    value: function end(fnStrOrNum) {
      var _this2 = this;

      var endType = isType(fnStrOrNum);
      var self = this;

      if (endType === 'function') {
        this.endFn = function () {
          return fnStrOrNum(_this2.sentence);
        };
      } else if (endType === 'string') {
        this.endFn = function () {
          return _this2.sentence.split(' ').slice(-1)[0] === fnStrOrNum;
        };
      } else if (endType === 'number' || fnStrOrNum === undefined) {
        fnStrOrNum = fnStrOrNum || Infinity;
        this.endFn = function () {
          return self.sentence.split(' ').length > fnStrOrNum;
        };
      } else {
        throw new Error('Must pass a function, string or number into end()');
      }
      return this;
    }
  }, {
    key: '_normalize',
    value: function _normalize(word) {
      return this._normalizeFn(word);
    }
  }, {
    key: 'normalize',
    value: function normalize(fn) {
      this._normalizeFn = fn;
      return this;
    }
  }], [{
    key: 'VERSION',
    get: function get() {
      return require('../package').version;
    }
  }, {
    key: 'MarkovChain',
    get: function get() {
      // load older MarkovChain
      return require('../older/index.js').MarkovChain;
    }
  }]);

  return MarkovChain;
})();

module.exports = MarkovChain;